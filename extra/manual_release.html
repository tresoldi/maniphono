<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Maniphono</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Maniphono</h1>
</header>
<p><code>maniphono</code> is a library for the symbolic manipulation of phonological units, designed as a solution historical phonology. While offering two standard models for operation, one modified from the IPA but following as much as possible its descriptors and one using distinctive features which is designed for machine learning, it is designed to support custom phonological models, trying as much as possible to be agnostic about the theoretical background. For example, contrary to most computational systems, it does not force consonants and vowels to be separated, and in fact allows pure systems of distinctive features where all possible sounds are expressed using the same matrix. It also gives particular attention since design stage to the role of suprasegmentals.</p>
<p><code>maniphono</code> operates on a hierarchy of phonological abstractions, all which are related in some way to a “phonological model” that serves as the basis of all operations. This hierarchy is:</p>
<ul>
<li>a “phonological model” comprises a set of features operating in a many-valued logic system: each <code>feature</code> may be either undefined or defined by defined by one and only one “feature value” (or <code>favalue</code>) and a map of sounds (given by their graphemes) and the feature values that define them</li>
<li>a “sound” is a bundle of zero or more feature values and is intended to mostly map individual abstract acoustic performances</li>
<li>a “segment” is a unit of analysis, as decided by the user; the most common segment is, by far, a “sound segment”, which is a segment composed of one (monosonic segment) or more (polysonic segment) sounds</li>
<li>a “sequence” is an ordered collection of segments and a set of information on suprasegmental properties, such as syllable breaks, tones, etc.</li>
</ul>
<p>Each unit is described in more detail in the subsequent sections. As as set of examples, however:</p>
<ul>
<li><code>model_mipa</code> is the standard phonological model in <code>maniphono</code>, comprised (at the time of writing) of 20 features (such as <code>manner</code> and <code>length</code>), 64 fvalues (such as <code>affricate</code> and <code>approximant</code>, values of the <code>manner</code> feature, and <code>half-long</code> and <code>long</code>, values of the <code>length</code> feature), and 231 graphemes (such as <code>a</code>, defined as an <code>open front unrounded vowel</code>)</li>
<li>sounds are to a large extend phonological abstractions represented by a single IPA glyph (potentially with diacritics), such as <code>open front unrounded vowel</code> (that is, /a/) or <code>voiced alveolar non-sibilant lateral affricate consonant</code> (that is, /dɮ/). Sounds can also be “partial”, in the sense that they are not fully defined and thus represent what is normally called a “class” of sounds, such as <code>glottal consonant</code> (represented by <code>H</code>)</li>
<li>a sound segment is intended as a unit of analysis, contingent to the user decisions. For example, a bisonic segment can be used to represent a diphthong in case they are supposed to be treated as a single unit of analysis (such as <code>/a+j/</code>, in <code>maniphono</code>’s notation), which is different from a sequence of two monosonic segments (that is, <code>/a j/</code>)</li>
<li>a sequence is a list of segments, such as <code>[p a p a+j]</code>, which is a sequence of four segments (the last of which is composed of two sounds). It can carry additional information, such as word boundaries as in <code>[# p a p a+j #]</code>, syllable breaks as in <code>[# p a . p a+j #]</code>, and tonal information as in <code>[# p a ˧˩ . p a+j ˨˦ #]</code></li>
</ul>
<h2 id="phonomodel">PhonoModel</h2>
<p>As mentioned above, a “phonological model” is composed of two main sources:</p>
<ul>
<li>a feature definition</li>
<li>a sound definition</li>
</ul>
<h3 id="feature-definition">Feature definition</h3>
<p>Features are defined in a tabular file named <code>model.csv</code> with contents similar to the snippet below:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">FEATURE</th>
<th style="text-align: left;">FVALUE</th>
<th style="text-align: left;">RANK</th>
<th style="text-align: left;">PREFIX</th>
<th style="text-align: left;">SUFFIX</th>
<th style="text-align: left;">CONSTRAINTS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">aspiration</td>
<td style="text-align: left;">aspirated</td>
<td style="text-align: left;">6</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">ʰ</td>
<td style="text-align: left;">consonant</td>
</tr>
<tr class="even">
<td style="text-align: left;">centrality</td>
<td style="text-align: left;">back</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">U+0320</td>
<td style="text-align: left;">vowel</td>
</tr>
<tr class="odd">
<td style="text-align: left;">centrality</td>
<td style="text-align: left;">central</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">U+0308</td>
<td style="text-align: left;">vowel</td>
</tr>
<tr class="even">
<td style="text-align: left;">centrality</td>
<td style="text-align: left;">front</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">U+031F</td>
<td style="text-align: left;">vowel</td>
</tr>
<tr class="odd">
<td style="text-align: left;">centrality</td>
<td style="text-align: left;">near-back</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">vowel</td>
</tr>
<tr class="even">
<td style="text-align: left;">centrality</td>
<td style="text-align: left;">near-front</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">vowel</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ejection</td>
<td style="text-align: left;">ejective</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">plosive|fricative|affricate</td>
</tr>
</tbody>
</table>
<p>The most important field for each row, and the only one that needs to be unique in the row, is the “FVALUE” one, as each row reports one “fvalue”. The “fvalue” labels have names in all lower-case letters, with optional dashes, and must be unique across the entire model. There cannot be repeated fvalue names, even if they cannot apply to the same sound: as a consequence, for example, the MIPA model has a feature “nasal” which applies to consonants only, and a feature “nasalized” which applies to vowels only.</p>
<p>The “FEATURE” column reports the feature in the model to which the fvalue refers to. Each sound in <code>maniphono</code> can have at most one fvalue per feature set, so that it is possible to ask questions such as “which is fvalue for ‘centrality’ in sound X” or “is ‘front’ the fvalue for ‘centrality’ in sound Y”.</p>
<p>“RANK”, “PREFIX”, and “SUFFIX” are properties mostly used for converting from and to graphemic representations, such as making sure that ‘voiceless bilabial plosive consonant’ is converted to “p”. The first is an integer number that informs, in descending order, how “important” a value is, so that, when presenting information to the user, our results are reproducible and we always obtain ‘voiceless bilabial plosive consonant’ and not ‘voiceless bilabial consonant plosive’ (which is, however, accepted as an input). Note that ranks are determined per fvalue and not per feature basis, as giving more fine-grained options about how to build the names. “PREFIX” and “SUFFIX” are, as expected, substrings that will attached to base graphemes in order to modify them; the order of addition follows the “RANK” property, so here as well the results are reproducible. Both “PREFIX” and “SUFFIX” can be given as Unicode charpoints. If an affix is needed when building a graphemic representation and it is not available, the library will fall back to adding the corresponding fvalue as a modifier.</p>
<p>“CONSTRAINTS” is a non-mandatory field which allows a detailed specification of which fvalues must or must not be set for a given fvalue to be present in a sound. They can be used internally for a variety of purposes, such as making sure that sounds or groups of sounds considered impossible are not accepted (such “sibilant laryngeals”, in the <code>mipa</code> model) and that some fvalues are automatically added when necessary (such as automatically marking all “sibilants” as “fricatives” in the same <code>mipa</code> model). The restriction that each can have at most one fvalue per feature can be interpreted as a list of constraints automatically added, where each fvalue implies the’ absence of the fvalues of the same feature. The syntax for the “CONSTRAINTS” field can express many nuances and interdependencies, and is explained in subsection X.</p>
<h4 id="sound-definition">Sound definition</h4>
<p>Sounds are defined in a tabular file named <code>sounds.csv</code> with contents similar to the snippet below:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">GRAPHEME</th>
<th style="text-align: left;">DESCRIPTION</th>
<th style="text-align: left;">CLASS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">V</td>
<td style="text-align: left;">vowel</td>
<td style="text-align: left;">True</td>
</tr>
<tr class="even">
<td style="text-align: left;">F</td>
<td style="text-align: left;">fricative consonant</td>
<td style="text-align: left;">True</td>
</tr>
<tr class="odd">
<td style="text-align: left;">a</td>
<td style="text-align: left;">open front unrounded vowel</td>
<td style="text-align: left;">False</td>
</tr>
<tr class="even">
<td style="text-align: left;">ã</td>
<td style="text-align: left;">open front unrounded vowel nasalized</td>
<td style="text-align: left;">False</td>
</tr>
<tr class="odd">
<td style="text-align: left;">b</td>
<td style="text-align: left;">voiced bilabial plosive consonant</td>
<td style="text-align: left;">False</td>
</tr>
</tbody>
</table>
<p>“GRAPHEME” is a base grapheme representation, and it is recommended that it follows the IPA as close as possible. As the “PREFIX” and “AFFIX” fields in model, this field accepts Unicode charpoints. Note, that internally the graphemes will always be normalized and returned following the NFD, that is, the Normalization Form Canonical Decomposition, when characters are decomposed by canonical equivalence, and multiple combining characters are arranged in a specific order. For more information, see subsection X.</p>
<p>The “DESCRIPTION” is a list of one or more fvalues that define the corresponding grapheme. It is not necessary for them to follow the ranks of the fvalues. While it is recommended to separate the fvalues by a single white space, there is some flexibility in terms of the syntax defining an “fvalue list” (see subsection X).</p>
<p>The “CLASS” column reports a boolean information on whether the sound is partial (<code>True</code>) or not (<code>False</code>). Sound partiality is an attribute mostly used internally for forward and backward operation when applying a sound change, and for most common purposes the sounds that can be represented in IPA can be considered non-partial. It is recommended, following the practice in the literature, that partial sounds are defined with capital letters.</p>
<p>As expected, there can be no duplicates in terms of graphemes (the same grapheme specified with two equivalent flists) and of fvalue lists (two equivalent flists mapping to different graphemes). The library will check for these restrictions when loading a model.</p>
<h3 id="fvalue-list-syntax">fvalue list syntax</h3>
<p>lorem ipsum</p>
<h3 id="constraint-syntax">Constraint syntax</h3>
<p>lorem ipsum</p>
<h3 id="unicode-normalization">Unicode normalization</h3>
<p>lorem ipsum</p>
<h2 id="usage">Usage</h2>
<p>The library is intended to be used as normal Python package, trying to follow the conventions and expectations of its programming language. A few decisions on implementation might fall short in this principle, but they are justified by the future plans of offering an equivalent interface in different programming languages that can easily used on client browser connections and/or compiled to machine code for easier parallel processing.</p>
<p>The library is imported as expected. It is currently distributed with two models, <code>mipa</code> and <code>tresoldi</code>, which offer a modified version of IPA and one of full binary distinctive features that is intended mostly for machine learning approaches. In all cases, the <code>mipa</code> model is used as default.</p>
<div class="sourceCode" id="cb1" data-startFrom="1"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> maniphono</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="bu">print</span>(maniphono.model_mipa)</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="bu">print</span>(maniphono.model_tresoldi)</span></code></pre></div>
<h3 id="sounds">Sounds</h3>
<p>A <code>Sound</code> can be initialized either with a grapheme, by default, or a description. Descriptions can be either a list of values or a string listing different values and separated by a standard delimiter such as spaces or commas. A model must also be provided, defaulting to <code>mipa</code> as mentioned above. Segments can be “visualized” with <code>str()</code>, returning a graphemic representation, or with <code>repr()</code>, returned a descriptive representation.</p>
<div class="sourceCode" id="cb2" data-startFrom="4"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python" style="counter-reset: source-line 3;"><span id="cb2-4"><a href="#cb2-4"></a>snd1 <span class="op">=</span> maniphono.Sound(<span class="st">&quot;p&quot;</span>)</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="bu">str</span>(snd1), <span class="bu">repr</span>(snd1)</span>
<span id="cb2-6"><a href="#cb2-6"></a>snd2 <span class="op">=</span> maniphono.Sound(description<span class="op">=</span><span class="st">&quot;voiceless bilabial plosive consonant&quot;</span>)</span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="bu">str</span>(snd2), <span class="bu">repr</span>(snd2)</span>
<span id="cb2-8"><a href="#cb2-8"></a>snd3 <span class="op">=</span> maniphono.Sound(<span class="st">&quot;a&quot;</span>, model<span class="op">=</span>maniphono.model_tresoldi)</span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="bu">str</span>(snd3), <span class="bu">repr</span>(snd3)</span></code></pre></div>
<p>The easiest way to manipulate sounds is using the add (<code>+</code>) and sub (<code>-</code>) operators, which accept both single and multiple values. If a value from a feature that is already set is added, it will be replaced.</p>
<div class="sourceCode" id="cb3" data-startFrom="10"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python" style="counter-reset: source-line 9;"><span id="cb3-10"><a href="#cb3-10"></a>snd1 <span class="op">+=</span> <span class="st">&#39;voiced&#39;</span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="bu">str</span>(snd1), <span class="bu">repr</span>(snd1)</span>
<span id="cb3-12"><a href="#cb3-12"></a>snd2 <span class="op">+=</span> <span class="st">&#39;velar,aspirated,labialized&#39;</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="bu">str</span>(snd2), <span class="bu">repr</span>(snd2)</span>
<span id="cb3-14"><a href="#cb3-14"></a>snd2 <span class="op">-=</span> <span class="st">&#39;aspirated&#39;</span></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="bu">str</span>(snd2), <span class="bu">repr</span>(snd2)</span></code></pre></div>
<p>A dictionary of features and values can be easily obtained:</p>
<div class="sourceCode" id="cb4" data-startFrom="16"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python" style="counter-reset: source-line 15;"><span id="cb4-16"><a href="#cb4-16"></a>snd2.feature_dict()</span></code></pre></div>
<p>If a grapheme is not available, either because the sound is not complete or because no diacritic is offered in the model, the library will try to be explicit about its representation.</p>
<div class="sourceCode" id="cb5" data-startFrom="17"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python" style="counter-reset: source-line 16;"><span id="cb5-17"><a href="#cb5-17"></a>snd4 <span class="op">=</span> maniphono.Sound(description<span class="op">=</span><span class="st">&quot;voiceless consonant&quot;</span>)</span>
<span id="cb5-18"><a href="#cb5-18"></a><span class="bu">str</span>(snd4), <span class="bu">repr</span>(snd4)</span></code></pre></div>
<p>While the results are technically correct, the library still needs work for always returning good representations when it computes the grapheme.</p>
<div class="sourceCode" id="cb6" data-startFrom="19"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python" style="counter-reset: source-line 18;"><span id="cb6-19"><a href="#cb6-19"></a>snd5 <span class="op">=</span> maniphono.Sound(<span class="st">&quot;kʰʷ[voiced]&quot;</span>)</span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="bu">str</span>(snd5), <span class="bu">repr</span>(snd5)</span></code></pre></div>
<h3 id="segments">Segments</h3>
<p>Segments can combine sounds of different models. The decision of what makes up a segment is entirely up to the user; the class can be initialized with a <code>Sound</code>, in case of monosonic segments, or with an ordered list of sounds.</p>
<p>Segments can be represented with <code>__str__</code> and can include a delimiter, by default a <code>+</code> sign.</p>
<div class="sourceCode" id="cb7" data-startFrom="21"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python" style="counter-reset: source-line 20;"><span id="cb7-21"><a href="#cb7-21"></a>snd1 <span class="op">=</span> maniphono.Sound(<span class="st">&quot;w&quot;</span>)</span>
<span id="cb7-22"><a href="#cb7-22"></a>snd2 <span class="op">=</span> maniphono.Sound(<span class="st">&quot;a&quot;</span>)</span>
<span id="cb7-23"><a href="#cb7-23"></a>snd3 <span class="op">=</span> maniphono.Sound(<span class="st">&quot;j&quot;</span>, model<span class="op">=</span>maniphono.model_tresoldi)</span>
<span id="cb7-24"><a href="#cb7-24"></a>seg1 <span class="op">=</span> maniphono.Segment(snd1)</span>
<span id="cb7-25"><a href="#cb7-25"></a>seg2 <span class="op">=</span> maniphono.Segment([snd2, snd3])</span>
<span id="cb7-26"><a href="#cb7-26"></a>seg3 <span class="op">=</span> maniphono.Segment([snd1, snd2, snd3])</span>
<span id="cb7-27"><a href="#cb7-27"></a><span class="bu">str</span>(seg1), <span class="bu">str</span>(seg2), <span class="bu">str</span>(seg3)</span></code></pre></div>
<h3 id="sequences">Sequences</h3>
<p>Sequences combine segments in order.</p>
<p>Sequences can be represented with <code>__str__</code> and always use a white space as a delimiter (following CLDF convention) as well as leading and trailing square brackets (<code>[</code> and <code>]</code>).</p>
<div class="sourceCode" id="cb8" data-startFrom="28"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python" style="counter-reset: source-line 27;"><span id="cb8-28"><a href="#cb8-28"></a>snd1, snd2, snd3 <span class="op">=</span> maniphono.Sound(<span class="st">&quot;p&quot;</span>), maniphono.Sound(<span class="st">&quot;a&quot;</span>), maniphono.Sound(<span class="st">&quot;w&quot;</span>)</span>
<span id="cb8-29"><a href="#cb8-29"></a>seg1, seg2, seg3 <span class="op">=</span> maniphono.Segment(snd1), maniphono.Segment(snd2), maniphono.Segment([snd3])</span>
<span id="cb8-30"><a href="#cb8-30"></a>seg4 <span class="op">=</span> maniphono.Segment([snd2, snd3])</span>
<span id="cb8-31"><a href="#cb8-31"></a><span class="bu">str</span>(seg1), <span class="bu">str</span>(seg2), <span class="bu">str</span>(seg3), <span class="bu">str</span>(seg4)</span>
<span id="cb8-32"><a href="#cb8-32"></a>seq1 <span class="op">=</span> maniphono.SegSequence([seg1, seg2])</span>
<span id="cb8-33"><a href="#cb8-33"></a>seq2 <span class="op">=</span> maniphono.SegSequence([seg1, seg2, seg3])</span>
<span id="cb8-34"><a href="#cb8-34"></a>seq3 <span class="op">=</span> maniphono.SegSequence([seg1, seg4])</span>
<span id="cb8-35"><a href="#cb8-35"></a>seq4 <span class="op">=</span> maniphono.SegSequence([seg1, seg2, seg3, seg1, seg4])</span>
<span id="cb8-36"><a href="#cb8-36"></a><span class="bu">str</span>(seq1), <span class="bu">str</span>(seq2), <span class="bu">str</span>(seq3), <span class="bu">str</span>(seq4)</span></code></pre></div>
<h3 id="operations">Operations</h3>
<p><code>PhonoModel</code> offers a number of auxiliary methods.</p>
<p>The <code>.values2sounds()</code> method will take a list of value constraints, both in terms of presence and absence, and returned an order list of all graphemes defined in the model that satisfy the constraint.</p>
<div class="sourceCode" id="cb9" data-startFrom="37"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python" style="counter-reset: source-line 36;"><span id="cb9-37"><a href="#cb9-37"></a><span class="op">&gt;&gt;&gt;</span> maniphono.model_mipa.values2graphemes(<span class="st">&quot;+vowel +front -close&quot;</span>)</span></code></pre></div>
<pre class="stderr"><code>  File &quot;source.py&quot;, line 37
    &gt;&gt;&gt; maniphono.model_mipa.values2graphemes(&quot;+vowel +front -close&quot;)
    ^
SyntaxError: invalid syntax</code></pre>
<p>The <code>.minimal_matrix()</code> method will take a list of graphemes and return a dictionary with the minimum set of features in which they differ.</p>
<div class="sourceCode" id="cb11" data-startFrom="38"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python" style="counter-reset: source-line 37;"><span id="cb11-38"><a href="#cb11-38"></a>maniphono.model_mipa.minimal_matrix([<span class="st">&quot;t&quot;</span>, <span class="st">&quot;d&quot;</span>])</span>
<span id="cb11-39"><a href="#cb11-39"></a><span class="bu">dict</span>(maniphono.model_mipa.minimal_matrix([<span class="st">&quot;t&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="st">&quot;s&quot;</span>]))</span></code></pre></div>
<p>Similarly, the <code>.class_features()</code> method will take a list of graphemes and return a dictionary of features and values the graphemes have in common. It can be used to discover what features make up a class with these sounds.</p>
<div class="sourceCode" id="cb12" data-startFrom="40"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python" style="counter-reset: source-line 39;"><span id="cb12-40"><a href="#cb12-40"></a>maniphono.model_mipa.class_features([<span class="st">&quot;t&quot;</span>, <span class="st">&quot;d&quot;</span>])</span>
<span id="cb12-41"><a href="#cb12-41"></a>maniphono.model_mipa.class_features([<span class="st">&quot;t&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="st">&quot;s&quot;</span>])</span></code></pre></div>
<p>The <code>.value_vector()</code> method will take a grapheme and return a list of feature names and a boolean vector of presence/absence. It is mostly intended for machine learning projects; for human explorations or categorical machine learning, there is an option to return non-binary vectors.</p>
<div class="sourceCode" id="cb13" data-startFrom="42"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python" style="counter-reset: source-line 41;"><span id="cb13-42"><a href="#cb13-42"></a>maniphono.model_mipa.value_vector(<span class="st">&quot;a&quot;</span>)</span>
<span id="cb13-43"><a href="#cb13-43"></a>maniphono.model_mipa.value_vector(<span class="st">&quot;a&quot;</span>, binary<span class="op">=</span><span class="va">False</span>)</span></code></pre></div>
<p>All models allow to compute a distance between two sounds, with the distance between a sound and itself set, by design, to zero. In some cases this experimental method will compute and cache and <code>sklearn</code> regressor, which can take a while.</p>
<div class="sourceCode" id="cb14" data-startFrom="44"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python" style="counter-reset: source-line 43;"><span id="cb14-44"><a href="#cb14-44"></a>maniphono.model_mipa.distance(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>)</span>
<span id="cb14-45"><a href="#cb14-45"></a>maniphono.model_mipa.distance(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;e&quot;</span>)</span>
<span id="cb14-46"><a href="#cb14-46"></a>maniphono.model_mipa.distance(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;ʒ&quot;</span>)</span></code></pre></div>
</body>
</html>
